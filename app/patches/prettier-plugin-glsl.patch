diff --git a/lib/prettier-plugin.cjs.js b/lib/prettier-plugin.cjs.js
index 96089b8baa0d4fc6defe1ac912bd70e708fbb72f..8d976d89829949a3fd6d848cc026d3976938c3a8 100644
--- a/lib/prettier-plugin.cjs.js
+++ b/lib/prettier-plugin.cjs.js
@@ -1,8 +1,7 @@
 'use strict';
 
-var prettier = require('prettier');
-var doc = require('prettier/doc');
-var lodash = require('lodash');
+var prettier = require('prettier/standalone');
+var doc = prettier.doc; // require('prettier/doc');
 var chevrotain = require('chevrotain');
 
 function _interopNamespaceDefault(e) {
@@ -739,7 +738,7 @@ var TOKEN;
     });
     TOKEN.NON_PP_IDENTIFIER = chevrotain.createToken({
         name: "NON_PP_IDENTIFIER",
-        pattern: /[a-z]\w*/i,
+        pattern: /[A-Za-z_]\w*/i,
         categories: TOKEN.IDENTIFIER,
     });
     TOKEN.PP = chevrotain.createToken({
@@ -768,6 +767,13 @@ var TOKEN;
     TOKEN.LINE = createPP("LINE", "line");
     TOKEN.EXTENSION = createPP("EXTENSION", "extension");
     TOKEN.INCLUDE = createPP("INCLUDE", "include");
+
+    // @note IT MUST BE DEFINED BEFORE TOKEN.HASH!!!
+    TOKEN.HASH_INCLUDE_MODULE = chevrotain.createToken({
+        name: "HASH_INCLUDE_MODULE",
+        pattern: /[ \t]*#[ \t]*include[ \t]+<[^>\r\n]+>/,
+    });
+
     TOKEN.HASH = chevrotain.createToken({ name: "HASH", pattern: "#" });
     TOKEN.KEYWORD = chevrotain.createToken({ name: "KEYWORD", pattern: chevrotain.Lexer.NA });
     const createKeyword = (const1, category) => chevrotain.createToken({
@@ -905,12 +911,14 @@ var TOKEN;
     // Only used in the context of #include.
     TOKEN.STRING = chevrotain.createToken({
         name: "STRING",
-        pattern: /"([^"\\]+|\\")+"/,
+        pattern: /"([^"\\\r\n]+|\\")+"/,
     });
+
+
 })(TOKEN || (TOKEN = {}));
 // IDENTIFIER needs to go last, but must be declared first
 // so it can be referenced in longerAlt
-const ALL_TOKENS = lodash.pull(Object.values(TOKEN), TOKEN.NON_PP_IDENTIFIER).flatMap((x) => (Array.isArray(x) ? x : [x]));
+const ALL_TOKENS = Object.values(TOKEN).filter(k => k !== TOKEN.NON_PP_IDENTIFIER).flatMap((x) => (Array.isArray(x) ? x : [x]));
 ALL_TOKENS.push(TOKEN.NON_PP_IDENTIFIER);
 const GLSL_LEXER = new chevrotain.Lexer(ALL_TOKENS, { ensureOptimizations: DEV });
 function checkLexingErrors(input, lexingResult) {
@@ -982,7 +990,7 @@ function isBitwiseOperator(tokenType) {
 new (class extends AbstractVisitor {
     constructor() {
         super(...arguments);
-        this.markError = lodash.noop;
+        this.markError = () => {};
     }
     eval(n, isDefined, markError) {
         this.isDefined = isDefined;
@@ -2307,26 +2315,27 @@ class GLSLParser extends chevrotain.EmbeddedActionsParser {
             return d;
         });
         this.ppInclude = this.RR("ppInclude", () => {
-            this.CONSUME(TOKEN.HASH);
-            this.CONSUME(TOKEN.INCLUDE);
             let str = "";
+        
             this.OR([
                 {
                     ALT: () => {
-                        str = this.CONSUME(TOKEN.STRING).image;
+                        const hashIncludeModule = this.CONSUME(TOKEN.HASH_INCLUDE_MODULE).image;
+                        
+                        str = hashIncludeModule.slice(
+                            hashIncludeModule.indexOf("<"),
+                        );
                     },
                 },
                 {
                     ALT: () => {
-                        // three.js style import
-                        //https://github.com/mrdoob/three.js/blob/98616257db739e50513437c6913156c17a6d40e4/src/renderers/webgl/WebGLProgram.js#L239
-                        this.CONSUME(TOKEN.LEFT_ANGLE);
-                        const t = this.CONSUME(TOKEN.IDENTIFIER);
-                        this.CONSUME(TOKEN.RIGHT_ANGLE);
-                        str = "<" + t.image + ">";
+                        this.CONSUME(TOKEN.HASH);
+                        this.CONSUME(TOKEN.INCLUDE);
+                        str = this.CONSUME(TOKEN.STRING).image;
                     },
-                },
+                }
             ]);
+
             return { kind: "ppInclude", what: str };
         });
         this.ppCall = this.RR("ppCall", () => {
@@ -2785,6 +2794,7 @@ function formatMacroDefinition(doc, options) {
     const formatted = printDocToString(doc, Object.assign({}, options, {
         printWidth: options.printWidth - 2,
     })).formatted;
+
     return formatted
         .trim()
         .replace(/^.*(?=[\r\n])/gm, (substr) => substr + " ".repeat(options.printWidth - 2 - substr.length + 1) + "\\");
@@ -3189,7 +3199,7 @@ const printers = {
                         parts.push(opening);
                         if (n.no) {
                             const commentOnOwnLine = n.yes.comments?.some((c) => c.trailing && c.tokenType === TOKEN.LINE_COMMENT) ||
-                                lodash.findLast(n.yes.comments, (c) => !c.leading && !c.trailing)
+                                n.yes.comments.findLast((c) => !c.leading && !c.trailing)
                                     ?.tokenType === TOKEN.LINE_COMMENT;
                             const elseOnSameLine = n.yes.kind === "compoundStatement" && !commentOnOwnLine;
                             parts.push(elseOnSameLine ? " " : hardline);
@@ -3373,6 +3383,8 @@ const printers = {
                     case "variableExpression":
                         return n.var.image;
                     case "ppDefine": {
+// console.log(n.tokens);
+
                         options.inMacro = n.params;
                         const doc = group([
                             "#define",
@@ -3384,11 +3396,13 @@ const printers = {
                             indent([
                                 line,
                                 n.node
-                                    ? paren(p("node"), isExpression(n.node))
+                                    // @note don't wrap define values in parenthesis unless already wrapped
+                                    ? paren(p("node"), n.tokens.at(0).tokenType.name === 'LEFT_PAREN' && n.tokens.at(-1).tokenType.name === 'RIGHT_PAREN')
                                     : fill(join(line, path.map(print, "tokens"))),
                             ]),
                         ]);
                         options.inMacro = undefined;
+
                         return formatMacroDefinition(doc, options);
                     }
                     case "ppDir": {
diff --git a/package.json b/package.json
index 5288492a36bddf02f0eebc28b424a77e285a5663..e5ca5876ee0ed0b62334bf4a00057db839e7533d 100644
--- a/package.json
+++ b/package.json
@@ -11,7 +11,10 @@
   ],
   "version": "0.2.0",
   "description": "Prettier (https://prettier.io) plugin for GLSL (OpenGL Shading Language).",
-  "exports": "./lib/prettier-plugin.cjs.js",
+  "exports": {
+    "default": "./lib/prettier-plugin.cjs.js",
+    "types": "./lib/prettier-plugin.d.ts"
+  },
   "type": "commonjs",
   "types": "lib/prettier-plugin.d.ts",
   "scripts": {
@@ -56,6 +59,7 @@
     "filesize": "^10.0.7",
     "jest": "^29.5.0",
     "node-fetch": "^3.3.1",
+    "prettier": "^3.5.3",
     "rollup": "^3.20.2",
     "rollup-plugin-terser": "^7.0.2",
     "ts-jest": "^29.0.5",
